# Лабораторная работа №9–10  
## Тема: Дополнительные алгоритмы сортировки и поиска

### Как я понял цели задания:
1. Применять навыки анализа алгоритмов (сортировки и поиска), изученные ранее.  
2. Разобрать новые алгоритмические структуры, понять их суть и сложность.  
3. Научиться самостоятельно писать, тестировать и анализировать новые алгоритмы в онлайн-IDE.  
4. Уметь оформлять работу в GitHub: аналитика в README, код в папке `Code/`.

---

# Алгоритмы сортировки

---

## 1. Блочная сортировка (Bucket Sort)

### Определение  
Bucket Sort — распределяет элементы по нескольким «корзинам» в зависимости от диапазона значений. Каждая корзина сортируется отдельно, затем корзины объединяются.

### Объяснение работы алгоритма  
1. Находим минимальный и максимальный элемент, определяем диапазон.  
2. Создаём `k` пустых корзин.  
3. Для каждого элемента вычисляем индекс корзины по формуле распределения.  
4. Складываем элементы в соответствующие корзины.  
5. Сортируем содержимое каждой корзины (например, встроенной сортировкой).  
6. Собираем итоговый массив в порядке корзин.

### Сложность  
- В среднем: **O(n)**  
- В худшем: **O(n²)** (если почти все элементы попадут в одну корзину)

### Почему такая сложность  
Если распределение данных равномерное, корзины маленькие → сортировка внутри них дешёвая → линейная сложность.  
Если распределение плохое, корзина одна → обычная сортировка → O(n²).

---

## 2. Блинная сортировка (Pancake Sort)

### Определение  
Алгоритм, который сортирует массив, используя единственную операцию — переворот (reverse) префикса массива.

### Как работает  
1. Находим максимальный элемент в неотсортированной части массива.  
2. Переворачиваем подмассив так, чтобы максимум оказался в начале.  
3. Переворачиваем подмассив нужной длины, чтобы максимум переместился в конец.  
4. Повторяем для оставшейся части.

### Сложность  
- **O(n²)**

### Почему такая сложность  
На каждом шаге два переворота и один поиск максимума → O(n). Таких шагов n → O(n²).

---

## 3. Сортировка бусинами (Bead Sort / Gravity Sort)

### Определение  
Имитация физической модели падения бусин на стержнях: значение элемента представляется количеством бусин, которые под действием «гравитации» выстраиваются вниз.

### Как работает  
1. Каждое число превращается в строку бусин (столько бусин, как значение числа).  
2. Бусины падают вниз, как в абаке.  
3. После оседания структуры считываем итоговые строки — получаем отсортированный массив.

### Сложность  
- Теоретическая: **O(n)**  
- Реальная (в программной модели): **O(n · max_value)**

### Почему такая сложность  
Работа зависит не только от n, но и от диапазона значений, потому что нужно создавать конструкции из «бусин» длиной `max_value`.

---

# Алгоритмы поиска

---

## 4. Поиск скачками (Jump Search)

### Определение  
Оптимизация линейного поиска для отсортированных массивов: массив делится на блоки длины √n, и алгоритм делает «прыжки» по блокам.

### Как работает  
1. Вычисляется шаг: `step = sqrt(n)`.  
2. Алгоритм прыгает через step элементов, пока не найдёт блок, превышающий target.  
3. В найденном блоке выполняется обычный линейный поиск.

### Сложность  
- **O(√n)**

### Почему такая сложность  
Количество прыжков = n / step.  
Линейный поиск внутри блока = step.  
Оптимальный шаг — sqrt(n), отсюда итоговое O(√n).

---

## 5. Экспоненциальный поиск (Exponential Search)

### Определение  
Комбинация последовательного увеличения индекса (1, 2, 4, 8, …) и бинарного поиска внутри найденного диапазона.

### Как работает  
1. Проверяем первый элемент.  
2. Увеличиваем индекс экспоненциально, пока не перейдём target.  
3. В найденном интервале запускаем бинарный поиск.

### Сложность  
- **O(log n)**

### Почему такая сложность  
Фаза экспоненциального поиска занимает O(log n) (потому что шаги 1, 2, 4, 8...).  
Бинарный поиск тоже O(log n).  
Суммарно также O(log n).

---

## 6. Тернарный поиск (Ternary Search)

### Определение  
В отличие от бинарного поиска, делит диапазон на три части и сравнивает элемент сразу с двумя точками — mid1 и mid2.

### Как работает  
1. Находим mid1 и mid2, разделяющие текущий диапазон на три части.  
2. Если target равен одному из них — найден.  
3. Иначе выбираем одну из трёх частей и повторяем.

### Сложность  
- **O(log n)**

### Почему такая сложность  
Хотя деление идёт на три части, число сравнений на итерацию растёт, но глубина рекурсии примерно логарифмическая.  
Преимуществ перед бинарным поиском почти нет.

---

# Структура репозитория

