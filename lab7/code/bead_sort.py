# bead_sort.py
# Сортировка бусинами (Bead Sort / Gravity Sort)
#
# Важно:
# - Работает только для неотрицательных целых чисел.
# - Имитирует поведение бусин (как на абаке): "опускает" единицы вниз.
# - Практически интересна как демонстрация; в Python реализация может быть менее эффективной
#   чем другие алгоритмы, особенно при большом диапазоне значений (из-за памяти).
#
# Временная сложность:
# - Теоретически O(n) при аппаратной реализации «гравитации», но в программной модели:
# - Часто O(n * max_value) или O(n + max_value) в зависимости от подхода.
#
# Пространственная сложность:
# - O(n + max_value) (матрица/столбцы)

from typing import List

def bead_sort(arr: List[int]) -> List[int]:
    """
    Реализация bead sort. Возвращает новый отсортированный список.
    Ограничение: элементы должны быть неотрицательными целыми.
    """
    if not arr:
        return []

    # Проверки и подготовка
    if any(x < 0 or int(x) != x for x in arr):
        raise ValueError("Bead sort supports only non-negative integers.")

    # Превращаем элементы в int (на случай float int-представлений)
    arr = [int(x) for x in arr]
    max_val = max(arr)
    n = len(arr)

    # Создаём "столбцы" (columns) — количество столбцов = max_val
    # Представим это как массив counts: counts[j] — сколько "бусин" в столбце j (по вертикали)
    counts = [0] * max_val
    # для каждой строки (элемента) ставим единицы в первых arr[i] столбцах
    for num in arr:
        for j in range(num):  # добавляем по одной "бусине" в первые num столбцов
            counts[j] += 1

    # Теперь "бусины" опустились вниз: чтобы получить отсортированный массив, читаем столбцы сверху вниз
    # Каждое значение в результатах равно количеству столбцов, где есть бусины у соответствующей строки
    # Считываем строки от низа к верху:
    result = []
    # Количество строк = n, высота каждого столбца = counts[j]
    # Для каждой строки i от 0 до n-1, количество бусин в этой строке равно количеству столбцов j для которых counts[j] > (n-1 - i)
    # Но проще: формируем result как [sum(1 for count in counts if count > i) for i in reversed(range(n))]
    for level in range(n-1, -1, -1):  # сверху вниз читаем осевую "матрицу"
        row_val = 0
        for count in counts:
            if count > level:
                row_val += 1
        result.append(row_val)

    # result сейчас — отсортированный в невозрастающем порядке (поскольку уровни считались сверху вниз)
    # Если исходный массив нужен в неубывающем порядке — отсортируем ascending:
    result_sorted = list(reversed(result))
    return result_sorted

if __name__ == "__main__":
    data = [5, 3, 1, 7, 4, 1, 3]
    print("Исходный массив (non-negative ints):", data)
    sorted_data = bead_sort(data)
    print("Отсортированный массив:", sorted_data)

    # Пояснение:
    # - counts[j] хранит, сколько строк (элементов) имеют 'бусину' в столбце j.
    # - затем читаем слева направо, сверху вниз, чтобы восстановить строки после "осадки".
