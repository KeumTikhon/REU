# pancake_sort.py
# Блинная сортировка (Pancake Sort)
#
# Идея:
# - Единственная разрешённая операция — переворот префикса массива (reverse prefix).
# - На каждом шаге находим максимум в неотсортированной части, переворачиваем,
#   чтобы он оказался в начале, затем переворачиваем всю эту неотсортированную часть,
#   чтобы максимум переместился в конец этой части.
#
# Ограничения:
# - Работает с любыми сравниваемыми элементами.
#
# Сложность:
# - Временная: O(n^2) (в худшем и среднем)
# - Пространственная: O(1) дополнительной памяти (in-place)

from typing import List

def flip(arr: List[int], k: int) -> None:
    """
    Переворачивает (реверсит) префикс длины k (индексы 0..k-1).
    Делает это in-place.
    """
    # Небольшая проверка: если k <= 1, ничего не делать
    i, j = 0, k - 1
    while i < j:
        arr[i], arr[j] = arr[j], arr[i]
        i += 1
        j -= 1

def pancake_sort(arr: List[int]) -> None:
    """
    Сортирует список in-place методом pancake sort.
    Возвращает None, модифицирует arr.
    """
    n = len(arr)
    # Проходим размер неотсортированной части от n до 1
    for curr_size in range(n, 1, -1):
        # Находим индекс максимального элемента в arr[0:curr_size]
        max_idx = 0
        for i in range(1, curr_size):
            if arr[i] > arr[max_idx]:
                max_idx = i

        # Если максимальный уже в конце неотсортированной части, ничего не делать
        if max_idx == curr_size - 1:
            continue

        # Если максимальный не в начале, перевернём префикс так, чтобы максимальный стал в начале
        if max_idx != 0:
            flip(arr, max_idx + 1)  # +1 т.к. flip ожидает длину

        # Теперь перевернём префикс длины curr_size — максимальный элемент окажется в позиции curr_size-1
        flip(arr, curr_size)

if __name__ == "__main__":
    data = [3, 6, 1, 10, 7, 2, 9, 5]
    print("Исходный массив:", data)
    pancake_sort(data)
    print("Отсортированный массив:", data)

    # Комментарий: алгоритм нагляден, но неэффективен для больших n из-за O(n^2).
