# bucket_sort.py
# Блочная (корзинная) сортировка
#
# Ограничения / предпосылки:
# - Наилучший случай: данные примерно равномерно распределены по диапазону
# - Здесь реализована универсальная версия: работает с числами (ints/floats), 
#   автоматически определяет диапазон и создаёт корзины.
#
# Временная сложность:
# - В среднем: O(n + k) ~ O(n) при удачном выборе корзин и равномерном распределении
# - Худший случай: O(n^2) (если все элементы попадают в одну корзину и сортировка внутри — O(n^2))
#
# Пространственная сложность: O(n + k) (доп. память для корзин)

from typing import List

def bucket_sort(arr: List[float], buckets_count: int = None) -> List[float]:
    """
    Сортирует список чисел методом корзин.
    - buckets_count: количество корзин; если None — установим равно n (длина массива).
    """
    n = len(arr)
    if n <= 1:
        return arr[:]  # ничего не делать для пустого или 1-элементного списка

    # Если не задано, количество корзин = n (обычная эвристика)
    if buckets_count is None:
        buckets_count = n

    # Находим минимальный и максимальный элементы, чтобы понимать диапазон
    min_val, max_val = min(arr), max(arr)
    # Если все элементы равны, возвращаем копию
    if min_val == max_val:
        return arr[:]

    # Создаём пустые корзины
    buckets = [[] for _ in range(buckets_count)]

    # Распределяем элементы по корзинам в зависимости от их относительной позиции в диапазоне
    range_val = max_val - min_val
    for x in arr:
        # Нормируем x в [0,1), умножаем на buckets_count -> индекс корзины
        # Важный момент: последний элемент может дать индекс == buckets_count, поправим это:
        idx = int(((x - min_val) / range_val) * (buckets_count - 1))
        buckets[idx].append(x)

    # Сортируем элементы внутри каждой корзины и собираем результат
    result = []
    for i, bucket in enumerate(buckets):
        # Внутреннюю сортировку можно выбрать: здесь вызов встроенного sorted (Timsort, O(m log m))
        # Можно заменить insertion sort для маленьких корзин — но встроенный быстрый и надёжен.
        if bucket:
            sorted_bucket = sorted(bucket)
            result.extend(sorted_bucket)
    return result

if __name__ == "__main__":
    # Пример использования
    data = [0.42, 0.32, 0.23, 0.52, 0.25, 0.47, 0.51, 0.10, 0.99, 0.37]
    print("Исходный массив:", data)
    sorted_data = bucket_sort(data)  # для float в [min,max]
    print("Отсортированный массив:", sorted_data)

    # Пример с целыми числами
    data2 = [29, 25, 3, 49, 9, 37, 21, 43]
    print("\nИсходный (ints):", data2)
    print("Отсортированный (ints):", bucket_sort(data2))
