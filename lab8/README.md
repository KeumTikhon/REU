# Лабораторная работа №11–12  
## Тема: Рекурсия, комбинаторика, backtracking, деревья и графы

### Как я понял цели работы:
1. Применить принципы рекурсии на разных структурах данных: число, строка, массив.  
2. Научиться использовать рекурсию в комбинаторных алгоритмах.  
3. Освоить поиск с возвратом (backtracking) для решения сложных задач перебора.  
4. Разобраться в рекурсивных алгоритмах графов (DFS, время входа/выхода).  
5. Закрепить умение оформлять алгоритмы и анализировать их сложность O(n).

---

# Выполненные варианты

Мне соответствуют варианты: **3, 4, 9, 11, 15, 18**.

Ниже — аналитика (определение, описание работы и сложность) для каждого задания.

---

# 1. Вариант 3 — Рекурсивный НОД (Алгоритм Евклида)

### Определение  
НОД двух чисел — это наибольшее число, на которое делятся оба.  
Алгоритм Евклида рекурсивно заменяет пару чисел `(a, b)` на `(b, a mod b)`.

### Как работает  
1. Если `b == 0`, то `a` — НОД.  
2. Иначе вызывается `gcd(b, a % b)`.  
3. Рекурсия продолжается, пока остаток не станет нулём.

### Сложность  
- **O(log(min(a,b)))**

### Почему такая сложность  
В алгоритме Евклида каждое рекурсивное вычисление уменьшает одно из чисел в среднем в несколько раз — происходит логарифмическое убывание.

---

# 2. Вариант 4 — Рекурсивный разворот строки

### Определение  
Разворот строки — получение строки в обратном порядке.  
Рекурсивно это делается с помощью сокращения задачи:  
`reverse(s) = reverse(s[1:]) + s[0]`.

### Как работает  
1. Базовый случай: если строка пустая или длина 1 → вернуть её.  
2. Рекурсивно разворачиваем всё, кроме первого символа.  
3. Добавляем первый символ в конец.  

### Сложность  
- **O(n)** по времени  
- **O(n)** по памяти из-за рекурсивных вызовов и конкатенации

### Почему такая сложность  
Каждый символ один раз участвует в рекурсивных вызовах. Глубина рекурсии = n.

---

# 3. Вариант 9 — Проверка массива на отсортированность (рекурсивно)

### Определение  
Рекурсивная проверка упорядоченности массива — сравнение текущего элемента со следующими.

### Как работает  
1. Базовый случай: если список длины 0 или 1 — он отсортирован.  
2. Проверяем: `arr[i] <= arr[i+1]`.  
3. Вызываем проверку для подмассива, начиная с `i+1`.

### Сложность  
- **O(n)**

### Почему такая сложность  
Проверяется каждый элемент один раз. Глубина рекурсии равна длине массива.

---

# 4. Вариант 11 — Перестановки строки (рекурсивно)

### Определение  
Перестановки строки — все возможные уникальные комбинации перестановок символов.

### Как работает  
1. Для каждой позиции пробуем поставить туда каждый возможный символ.  
2. Остальные символы переставляем рекурсивно.  
3. Когда строка сформирована полностью — добавляем в результат.

### Сложность  
- **O(n · n!)**

### Почему такая сложность  
Всего перестановок — `n!`, а формирование каждой требует `O(n)` операций копирования/сборки.

---

# 5. Вариант 15 — Все пути в лабиринте 5×5 (backtracking)

### Определение  
Задача поиска всех возможных путей из точки A в точку B в лабиринте (матрице), используя откат состояния (backtracking).

### Как работает  
1. Текущую клетку помечаем как посещённую.  
2. Пробуем пройти во всех допустимых направлениях (вверх, вниз, влево, вправо).  
3. Если пришли в точку выхода — фиксируем путь.  
4. При возврате откатываем состояние (снимаем отметку).

### Сложность  
- В худшем случае: **O(4^(n²))** — полный перебор  
- Реально меньше из-за стен/ограничений

### Почему такая сложность  
Алгоритм перебирает все возможные ходы в матрице.  
Backtracking = глубокий перебор всех путей.

---

# 6. Вариант 18 — DFS графа с временем входа/выхода

### Определение  
DFS — это рекурсивный обход в глубину.  
Для каждой вершины фиксируются два времени:  
- **time_in** — когда DFS "заходит" в вершину  
- **time_out** — когда DFS завершает работу с её поддеревом

### Как работает  
1. Увеличиваем глобальное время и записываем `time_in[v]`.  
2. Переходим в непосещённых соседей.  
3. После выхода из всех соседей увеличиваем время и логируем `time_out[v]`.

### Сложность  
- **O(V + E)**

### Почему такая сложность  
Каждая вершина и каждое ребро просматриваются ровно один раз.

---