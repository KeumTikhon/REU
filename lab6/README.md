### Как я понял цели задания:
1. Переносить знания — реализовать изученные алгоритмы (сортировки и поиски) на разных языках программирования (Python, C++, Java).  
2. Разобраться в принципах работы алгоритмов и оценке их сложности (Big O).  
3. Научиться работать с IDE и системами контроля версий (GitHub).  
4. Проверить понимание алгоритмических структур на практике.

---


**Сортировки:**
- **Selection Sort (выбором)** — ищет минимальный элемент и ставит в начало. Сложность: `O(n²)`.  
- **Bubble Sort (обменом)** — сравнивает соседние элементы, “всплывает” максимум. Сложность: `O(n²)`.  
- **Insertion Sort (вставками)** — вставляет элементы в отсортированную часть. Сложность: `O(n²)`.  
- **Merge Sort (слиянием)** — рекурсивно делит и сливает массив. Сложность: `O(n log n)`.  
- **Shell Sort (Шелла)** — улучшенная сортировка вставками с промежутками. Сложность: `O(n log² n)` (в среднем).  
- **Quick Sort (быстрая)** — делит по опорному элементу, рекурсивно сортирует части. Сложность: `O(n log n)` в среднем.  
- **Heap Sort (пирамидальная)** — строит max-heap и извлекает элементы. Сложность: `O(n log n)`.

**Поиски:**
- **Linear Search (последовательный)** — проверяет элементы по очереди. Сложность: `O(n)`.  
- **Binary Search (бинарный)** — делит отсортированный массив пополам. Сложность: `O(log n)`.  
- **Interpolation Search (интерполяционный)** — вычисляет вероятную позицию элемента. Сложность: `O(log log n)` (в лучшем случае).  
- **Fibonacci Search (поиск Фибоначчи)** — использует числа Фибоначчи для деления массива. Сложность: `O(log n)`.
